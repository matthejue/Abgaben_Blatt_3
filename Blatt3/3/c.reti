STOREIN SP DS 0
SUBI SP 1;
# b) start
LOADI IN2 4
# POLLING-LOOP start
LOADI IN1 0
LOADI DS 1048576  # so geht das viel eleganter
MULTI DS 1024  # Bitshiften
LOAD ACC 2
# SUBI ACC 1027010  # wieso diese Zahl? 0011111010101111000010 und mit minus geht das nicht, da ihr nicht wisst ob in den anderen bits 1 oder 0 steht, -0.25 ergibt keinen Sinn
# was haltet ihr von:
ANDI ACC 2;
# JUMP< -2 # Folgefehler
JUMP== -2
ADD IN1 1  # mit OR geht es übrigens auch und zwar an jeder belieben Stelle, ADD klappt nur wenn es sich um least significant bit handelt
# SUBI 2 10  # -0.25 den Befehl gibt es nicht
# ich schätze ihr wollt das Register wird auf 0 setzen
# das geht so:
SUBI ACC 2
STORE ACC 2
# JUMP -6  # beide jumps *1 und *2 springen nach hinten und der zweite jumpt sogar immer, das kann nicht stimmen. Dieser Jump nach hinten erigbt keinen Sinn -0.25
# POLLING-LOOP end
# MULTI IN1 100000000 # -0.25 ihr shiftet damit aber einmal zu viel
SUBI IN2 1
# LOAD ACC IN2  # den Befehl gibt es nicht -0.25
MOVE IN2 ACC  # den Befehl gibt es nicht
# JUMP= -4  # -0.25 die Bedingung des Jump ist genau falsch rum
JUMP== 3  # so sorgt ihr dafür, dass beim letzten mal nicht geshiftet wird
MULTI IN1 256  # 100000000
JUMP -12  # die Bedingung des Jump ist genau falsch rum
# b) end
# LOADI c a # diesen Befehl gibt es nicht, c muss ein Register sein -0.5
# Registser agieren als Booten, um Werte in Speicherzellen zu schreiben
# falls das ein weiteres Register sein soll?
# sobald alle Register alle gehen verwendet man den Stack
# ADD IN1 s # es geht eleganter:
# STOREIN c IN1 0
# ADDI c 1
# LOAD ACC 2
# SUBI ACC 11027 001
# JUMP< − 18
# LOAD ACC t
MOVE IN1 ACC
DIVI ACC 1048576;
DIVI ACC 4;
MODI ACC 1024;
OPLUSI ACC 448;
JUMP== 8;  # -0.25 falsche Sprungdistanz
LOADIN SP ACC 1
ADDI SP 1
STOREIN ACC IN1 0
ADDI ACC 1
STOREIN SP ACC 0
SUBI SP 1
JUMP -27;
